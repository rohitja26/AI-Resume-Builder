{"version":3,"file":"validators.js","sources":["../../../src/services/entity-validator/validators.ts"],"sourcesContent":["import _ from 'lodash';\nimport { yup } from '@strapi/utils';\nimport type { Schema, Struct, Modules } from '@strapi/types';\nimport blocksValidator from './blocks-validator';\n\nimport type { ComponentContext } from '.';\n\ninterface ValidatorMetas<TAttribute extends Schema.Attribute.AnyAttribute> {\n  attr: TAttribute;\n  model: Struct.ContentTypeSchema;\n  updatedAttribute: { name: string; value: unknown };\n  entity: Modules.EntityValidator.Entity;\n  componentContext: ComponentContext;\n}\n\ninterface ValidatorOptions {\n  isDraft: boolean;\n  locale?: string;\n}\n\n/* Validator utils */\n\n/**\n * Adds minLength validator\n */\nconst addMinLengthValidator = (\n  validator: yup.StringSchema,\n  {\n    attr,\n  }: {\n    attr:\n      | Schema.Attribute.String\n      | Schema.Attribute.Text\n      | Schema.Attribute.RichText\n      | Schema.Attribute.Password\n      | Schema.Attribute.Email\n      | Schema.Attribute.UID;\n  },\n  { isDraft }: ValidatorOptions\n) => {\n  return attr.minLength && _.isInteger(attr.minLength) && !isDraft\n    ? validator.min(attr.minLength)\n    : validator;\n};\n\n/**\n * Adds maxLength validator\n * @returns {StringSchema}\n */\nconst addMaxLengthValidator = (\n  validator: yup.StringSchema,\n  {\n    attr,\n  }: {\n    attr:\n      | Schema.Attribute.String\n      | Schema.Attribute.Text\n      | Schema.Attribute.RichText\n      | Schema.Attribute.Password\n      | Schema.Attribute.Email\n      | Schema.Attribute.UID;\n  }\n) => {\n  return attr.maxLength && _.isInteger(attr.maxLength) ? validator.max(attr.maxLength) : validator;\n};\n\n/**\n * Adds min integer validator\n * @returns {NumberSchema}\n */\nconst addMinIntegerValidator = (\n  validator: yup.NumberSchema,\n  {\n    attr,\n  }: {\n    attr: Schema.Attribute.Integer | Schema.Attribute.BigInteger;\n  }\n) => (_.isNumber(attr.min) ? validator.min(_.toInteger(attr.min)) : validator);\n\n/**\n * Adds max integer validator\n */\nconst addMaxIntegerValidator = (\n  validator: yup.NumberSchema,\n  {\n    attr,\n  }: {\n    attr: Schema.Attribute.Integer | Schema.Attribute.BigInteger;\n  }\n) => (_.isNumber(attr.max) ? validator.max(_.toInteger(attr.max)) : validator);\n\n/**\n * Adds min float/decimal validator\n */\nconst addMinFloatValidator = (\n  validator: yup.NumberSchema,\n  {\n    attr,\n  }: {\n    attr: Schema.Attribute.Decimal | Schema.Attribute.Float;\n  }\n) => (_.isNumber(attr.min) ? validator.min(attr.min) : validator);\n\n/**\n * Adds max float/decimal validator\n */\nconst addMaxFloatValidator = (\n  validator: yup.NumberSchema,\n  {\n    attr,\n  }: {\n    attr: Schema.Attribute.Decimal | Schema.Attribute.Float;\n  }\n) => (_.isNumber(attr.max) ? validator.max(attr.max) : validator);\n\n/**\n * Adds regex validator\n */\nconst addStringRegexValidator = (\n  validator: yup.StringSchema,\n  {\n    attr,\n  }: {\n    attr:\n      | Schema.Attribute.String\n      | Schema.Attribute.Text\n      | Schema.Attribute.RichText\n      | Schema.Attribute.Password\n      | Schema.Attribute.Email\n      | Schema.Attribute.UID;\n  }\n) => {\n  return 'regex' in attr && !_.isUndefined(attr.regex)\n    ? validator.matches(new RegExp(attr.regex), { excludeEmptyString: !attr.required })\n    : validator;\n};\n\n/**\n * Adds unique validator\n */\nconst addUniqueValidator = <T extends yup.AnySchema>(\n  validator: T,\n  {\n    attr,\n    model,\n    updatedAttribute,\n    entity,\n    componentContext,\n  }: ValidatorMetas<Schema.Attribute.AnyAttribute & Schema.Attribute.UniqueOption>,\n  options: ValidatorOptions\n): T => {\n  if (attr.type !== 'uid' && !attr.unique) {\n    return validator;\n  }\n\n  return validator.test('unique', 'This attribute must be unique', async (value) => {\n    const isPublish = options.isDraft === false;\n\n    /**\n     * If the attribute value is `null` we want to skip the unique validation.\n     * Otherwise it'll only accept a single `null` entry in the database.\n     */\n    if (_.isNil(value)) {\n      return true;\n    }\n\n    /**\n     * If we are updating a draft and the value is unchanged we skip the unique verification. This will\n     * prevent the validator to be triggered in case the user activated the\n     * unique constraint after already creating multiple entries with\n     * the same attribute value for that field.\n     */\n    if (!isPublish && value === entity?.[updatedAttribute.name]) {\n      return true;\n    }\n\n    let queryUid: string;\n    let queryWhere: Record<string, any> = {};\n\n    const hasPathToComponent = componentContext?.pathToComponent?.length > 0;\n    if (hasPathToComponent) {\n      const hasRepeatableData = componentContext.repeatableData.length > 0;\n      if (hasRepeatableData) {\n        // If we are validating a unique field within a repeatable component,\n        // we first need to ensure that the repeatable in the current entity is\n        // valid against itself.\n\n        const { name: updatedName, value: updatedValue } = updatedAttribute;\n        // Construct the full path to the unique field within the component.\n        const pathToCheck = [...componentContext.pathToComponent.slice(1), updatedName].join('.');\n\n        // Extract the values from the repeatable data using the constructed path\n        const values = componentContext.repeatableData.map((item) => {\n          return pathToCheck.split('.').reduce((acc, key) => acc[key], item as any);\n        });\n\n        // Check if the value is repeated in the current entity\n        const isUpdatedAttributeRepeatedInThisEntity =\n          values.filter((value) => value === updatedValue).length > 1;\n\n        if (isUpdatedAttributeRepeatedInThisEntity) {\n          return false;\n        }\n      }\n\n      /**\n       * When `componentContext` is present it means we are dealing with a unique\n       * field within a component.\n       *\n       * The unique validation must consider the specific context of the\n       * component, which will always be contained within a parent content type\n       * and may also be nested within another component.\n       *\n       * We construct a query that takes into account the parent's model UID,\n       * dimensions (such as draft and publish state/locale) and excludes the current\n       * content type entity by its ID if provided.\n       */\n      const {\n        model: parentModel,\n        options: parentOptions,\n        id: excludeId,\n      } = componentContext.parentContent;\n      queryUid = parentModel.uid;\n\n      const whereConditions: Record<string, any> = {};\n      const isParentDraft = parentOptions && parentOptions.isDraft;\n\n      whereConditions.publishedAt = isParentDraft ? null : { $notNull: true };\n\n      if (parentOptions?.locale) {\n        whereConditions.locale = parentOptions.locale;\n      }\n\n      if (excludeId && !Number.isNaN(excludeId)) {\n        whereConditions.id = { $ne: excludeId };\n      }\n\n      queryWhere = {\n        ...componentContext.pathToComponent.reduceRight((acc, key) => ({ [key]: acc }), {\n          [updatedAttribute.name]: value,\n        }),\n\n        ...whereConditions,\n      };\n    } else {\n      /**\n       * Here we are validating a scalar unique field from the content type's schema.\n       * We construct a query to check if the value is unique\n       * considering dimensions (e.g. locale, publication state) and excluding the current entity by its ID if available.\n       */\n      queryUid = model.uid;\n      const scalarAttributeWhere: Record<string, any> = {\n        [updatedAttribute.name]: value,\n      };\n\n      scalarAttributeWhere.publishedAt = options.isDraft ? null : { $notNull: true };\n\n      if (options?.locale) {\n        scalarAttributeWhere.locale = options.locale;\n      }\n\n      if (entity?.id) {\n        scalarAttributeWhere.id = { $ne: entity.id };\n      }\n\n      queryWhere = scalarAttributeWhere;\n    }\n\n    // The validation should pass if there is no other record found from the query\n    // TODO query not working for dynamic zones (type === relation)\n    return !(await strapi.db.query(queryUid).findOne({ where: queryWhere }));\n  });\n};\n\n/* Type validators */\n\nconst stringValidator = (\n  metas: ValidatorMetas<\n    | Schema.Attribute.String\n    | Schema.Attribute.Text\n    | Schema.Attribute.RichText\n    | Schema.Attribute.Password\n    | Schema.Attribute.Email\n    | Schema.Attribute.UID\n  >,\n  options: ValidatorOptions\n) => {\n  let schema = yup.string().transform((val, originalVal) => originalVal);\n\n  schema = addMinLengthValidator(schema, metas, options);\n  schema = addMaxLengthValidator(schema, metas);\n  schema = addStringRegexValidator(schema, metas);\n  schema = addUniqueValidator(schema, metas, options);\n\n  return schema;\n};\n\nconst emailValidator = (\n  metas: ValidatorMetas<Schema.Attribute.Email>,\n  options: ValidatorOptions\n) => {\n  const schema = stringValidator(metas, options);\n  return schema.email().min(1, '${path} cannot be empty');\n};\n\nconst uidValidator = (metas: ValidatorMetas<Schema.Attribute.UID>, options: ValidatorOptions) => {\n  const schema = stringValidator(metas, options);\n\n  return schema.matches(/^[A-Za-z0-9-_.~]*$/);\n};\n\nconst enumerationValidator = ({ attr }: { attr: Schema.Attribute.Enumeration }) => {\n  return yup\n    .string()\n    .oneOf((Array.isArray(attr.enum) ? attr.enum : [attr.enum]).concat(null as any));\n};\n\nconst integerValidator = (\n  metas: ValidatorMetas<Schema.Attribute.Integer | Schema.Attribute.BigInteger>,\n  options: ValidatorOptions\n) => {\n  let schema = yup.number().integer();\n\n  schema = addMinIntegerValidator(schema, metas);\n  schema = addMaxIntegerValidator(schema, metas);\n  schema = addUniqueValidator(schema, metas, options);\n\n  return schema;\n};\n\nconst floatValidator = (\n  metas: ValidatorMetas<Schema.Attribute.Decimal | Schema.Attribute.Float>,\n  options: ValidatorOptions\n) => {\n  let schema = yup.number();\n  schema = addMinFloatValidator(schema, metas);\n  schema = addMaxFloatValidator(schema, metas);\n  schema = addUniqueValidator(schema, metas, options);\n\n  return schema;\n};\n\nconst bigintegerValidator = (\n  metas: ValidatorMetas<Schema.Attribute.BigInteger>,\n  options: ValidatorOptions\n) => {\n  const schema = yup.mixed();\n  return addUniqueValidator(schema, metas, options);\n};\n\nconst datesValidator = (\n  metas: ValidatorMetas<\n    | Schema.Attribute.Date\n    | Schema.Attribute.DateTime\n    | Schema.Attribute.Time\n    | Schema.Attribute.Timestamp\n  >,\n  options: ValidatorOptions\n) => {\n  const schema = yup.mixed();\n  return addUniqueValidator(schema, metas, options);\n};\n\nexport default {\n  string: stringValidator,\n  text: stringValidator,\n  richtext: stringValidator,\n  password: stringValidator,\n  email: emailValidator,\n  enumeration: enumerationValidator,\n  boolean: () => yup.boolean(),\n  uid: uidValidator,\n  json: () => yup.mixed(),\n  integer: integerValidator,\n  biginteger: bigintegerValidator,\n  float: floatValidator,\n  decimal: floatValidator,\n  date: datesValidator,\n  time: datesValidator,\n  datetime: datesValidator,\n  timestamp: datesValidator,\n  blocks: blocksValidator,\n};\n"],"names":["_","value","yup"],"mappings":"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"}